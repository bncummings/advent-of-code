import java.io.File

infix operator fun Pair<Int, Int>.plus(other:Pair<Int, Int>):Pair<Int, Int> =
    Pair(this.first + other.first, this.second + other.second)

infix operator fun Pair<Int, Int>.minus(other:Pair<Int, Int>):Pair<Int, Int> =
    Pair(this.first - other.first, this.second - other.second)

infix operator fun Pair<Int, Int>.times(k:Int):Pair<Int, Int> =
    Pair(this.first * k , this.second * k)

/**
 * returns a vector from A to B
 */
fun calculateVector(a:Pair<Int,Int>, b:Pair<Int,Int>):Pair<Int, Int> =
    Pair(b.first - a.first, b.second - a.second)

/**
 * returns a list of strings/ matrix of characters
 */
fun getQuestionEightInput(filename: String): List<List<Char>> {
    val listOfStrings: MutableList<List<Char>> = mutableListOf()
    File(filename).forEachLine {
        listOfStrings.add(it.toList())
    }
    return listOfStrings
}

/**
 * collect all the anti-nodes in a set to avoid duplication problems
 */
val antiNodeSet = hashSetOf<Pair<Int, Int>>()

/**
 * add the two anti-nodes generated by a pair of antenna
 */
fun addAntiNodePositions(a:Pair<Int,Int>, b:Pair<Int,Int>, grid:List<List<Char>>) {
    if(a != b) {
        var i = 1;
        while(addToSet(b + (calculateVector(a,b) * i), grid)) {
            i++
        }


        var j = -1;
        while(addToSet(a - (calculateVector(a,b) * j), grid)) {
            j--
        }

    }
}

/**
 * get all the antennae of a specific frequency as distinct pairs of antennae
 * (edges in the graph)
 *
 * currently this will be n^2 where n is the max number of antena
 */
fun generateAntiNodesForAntenna(antenna:Pair<Int, Int>, grid:List<List<Char>>) {
    val frequency = grid[antenna.first][antenna.second]

    for(i in grid.indices) {
        for(j in grid.first().indices) {
            if(grid[i][j] == frequency) {
                addAntiNodePositions(antenna, Pair(i,j), grid)
            }
        }
    }
}

/**
 * goes through grid and adds the antinodes for each distinct frequency found
 */
fun countAntiNodes(grid:List<List<Char>>) {
    for(i in grid.indices) {
        for(j in grid.first().indices) {
            //disregard empty points
            if(grid[i][j] == '.') {
                continue
            }
            generateAntiNodesForAntenna(Pair(i, j), grid)
        }
    }
}

/**
 * checks that point lies on the grid and adds it to our set of points
 * @return true if the anti-node is on the grid
 */
fun addToSet(antiNode:Pair<Int,Int>, grid: List<List<Char>>): Boolean {
    // check that our new anti-node lies on the grid
    if(
        antiNode.first in grid.indices &&
        antiNode.second in grid.first().indices
    ) {
        antiNodeSet.add(antiNode)
        return true
    }
    return false
}

fun main() {
    val grid = getQuestionEightInput("src/main/resources/Day08.txt")
    countAntiNodes(grid)
    System.out.println(antiNodeSet.size)
}
